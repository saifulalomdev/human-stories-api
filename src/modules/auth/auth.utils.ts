// src/modules/auth/auth.utils.ts
import bcrypt from 'bcrypt';
import JWT, { SignOptions } from 'jsonwebtoken'; // Import SignOptions
import { env } from '@/config/env';
import { UserPublic } from '@/infrastructure/db';
import { RefreshTokenPayload } from '@/infrastructure/db/validators/sessions';


const SALT_ROUND = 10;
const ACCESS_TOKEN_SECRET = env.JWT_ACCESS_SECRET;
const REFRESH_TOKEN_SECRET = env.JWT_REFRESH_SECRET;

// Ensure these are cast to the specific type JWT expects
const ACCESS_TOKEN_EXIRES_IN = (env.JWT_ACCESS_SECRET_EXIRES_IN || "10m") as SignOptions['expiresIn'];
const REFRESH_TOKEN_EXIRES_IN = (env.JWT_REFRESH_SECRET_EXIRES_IN || "15d") as SignOptions['expiresIn'];

export type DecodedPayload = UserPublic;

export async function hashPassword(password: string): Promise<string> {
    return bcrypt.hash(password, SALT_ROUND);
}

export async function verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
}

// export const generateTokens = (payload: UserPublic) => {
//     // 1. Create a plain object. JWT.sign fails if the payload 
//     // is a class instance or has hidden Zod properties.
//     const jwtPayload = {
//         id: payload.id,
//         email: payload.email,
//         name: payload.name,
//     };

//     const accessToken = JWT.sign(jwtPayload, ACCESS_TOKEN_SECRET, {
//         expiresIn: ACCESS_TOKEN_EXIRES_IN,
//     });

//     const refreshToken = JWT.sign(jwtPayload, REFRESH_TOKEN_SECRET, {
//         expiresIn: REFRESH_TOKEN_EXIRES_IN,
//     });

//     return { accessToken, refreshToken };
// };

export const verifyAccessToken = (token: string) => {
    try {
        return JWT.verify(token, ACCESS_TOKEN_SECRET) as DecodedPayload;
    } catch (error) {
        return null;
    }
};

/**
 * 1. Generates a short-lived Access Token
 * Used for: Every request to protected routes.
 */
export const signAccessToken = (payload: UserPublic) => {
    return JWT.sign(
        { ...payload },
        ACCESS_TOKEN_SECRET,
        { expiresIn: ACCESS_TOKEN_EXIRES_IN }
    );
};

/**
 * 2. Generates a long-lived Refresh Token
 * Includes a unique 'jti' to track the session in the DB.
 */
export const signRefreshToken = (payload: UserPublic) => {
    const jti = crypto.randomUUID();

    const refreshToken = JWT.sign(
        { id: payload.id, jti },
        REFRESH_TOKEN_SECRET,
        { expiresIn: REFRESH_TOKEN_EXIRES_IN }
    );

    // Decode immediately to get the 'exp' claim generated by JWT
    const decoded = JWT.decode(refreshToken) as { exp: number };

    return {
        refreshToken,
        jti,
        expiresAt: new Date(decoded.exp * 1000) // Convert seconds to Date object
    };
};

export const verifyRefreshToken = (token: string) => {
    try {
        // We cast the result to our RefreshTokenPayload type
        return JWT.verify(token, env.JWT_REFRESH_SECRET) as RefreshTokenPayload;
    } catch (error) {
        // If signature is invalid or token is expired, return null
        return null;
    }
};